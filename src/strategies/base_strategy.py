"""
Abstract Base Strategy

Purpose:
    Defines the interface all trading strategies must implement.
    Provides common analysis and signal generation utilities.

Dependencies:
    - pandas for data handling

Logging:
    Strategy execution at INFO, signal generation at INFO.

Fallbacks:
    If individual indicator fails, it's skipped (not fatal).
"""

from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from datetime import datetime
from typing import Any, Dict, List, Optional

import pandas as pd

from src.monitoring.logger import get_logger
from src.utils.constants import AlertPriority, SignalType

logger = get_logger(__name__)


@dataclass
class TradingSignal:
    """Represents a trading signal generated by a strategy."""

    symbol: str
    company_name: str
    strategy_name: str
    signal_type: SignalType
    confidence: float  # 0.0 to 1.0
    entry_price: float
    target_price: float
    stop_loss: float
    priority: AlertPriority
    indicators_met: int
    total_indicators: int
    indicator_details: Dict[str, Any] = field(
        default_factory=dict
    )
    metadata: Dict[str, Any] = field(default_factory=dict)
    generated_at: datetime = field(
        default_factory=datetime.now
    )

    @property
    def target_percent(self) -> float:
        """Calculate target percentage from entry (always positive)."""
        if self.entry_price <= 0:
            return 0.0
        return (
            abs(self.target_price - self.entry_price)
            / self.entry_price
            * 100
        )

    @property
    def stop_loss_percent(self) -> float:
        """Calculate stop loss percentage from entry (always positive)."""
        if self.entry_price <= 0:
            return 0.0
        return (
            abs(self.entry_price - self.stop_loss)
            / self.entry_price
            * 100
        )

    @property
    def risk_reward_ratio(self) -> float:
        """Calculate risk-reward ratio (works for both BUY and SELL)."""
        risk = abs(self.entry_price - self.stop_loss)
        if risk <= 0:
            return 0.0
        reward = abs(self.target_price - self.entry_price)
        return reward / risk

    def to_dict(self) -> Dict[str, Any]:
        """Convert signal to dictionary."""
        return {
            "symbol": self.symbol,
            "company_name": self.company_name,
            "strategy_name": self.strategy_name,
            "signal_type": self.signal_type.value,
            "confidence": self.confidence,
            "entry_price": self.entry_price,
            "target_price": self.target_price,
            "stop_loss": self.stop_loss,
            "priority": self.priority.value,
            "indicators_met": self.indicators_met,
            "total_indicators": self.total_indicators,
            "target_percent": self.target_percent,
            "stop_loss_percent": self.stop_loss_percent,
            "risk_reward_ratio": self.risk_reward_ratio,
            "indicator_details": self.indicator_details,
            "metadata": self.metadata,
            "generated_at": self.generated_at.isoformat(),
        }


class BaseStrategy(ABC):
    """Abstract base class for trading strategies."""

    def __init__(self, config: Dict[str, Any]):
        """
        Initialize strategy with configuration.

        Args:
            config: Strategy configuration dictionary.
        """
        self.config = config
        self.strategy_config = config.get("strategy", {})
        self.name = self.strategy_config.get(
            "name", "Unknown Strategy"
        )
        self.version = self.strategy_config.get("version", "1.0")
        self.enabled = self.strategy_config.get("enabled", True)
        self.priority = self.strategy_config.get("priority", 10)

        self.filters_config = config.get("filters", {})
        self.indicators_config = config.get("indicators", [])
        self.signal_config = config.get("signal_generation", {})
        self.risk_config = config.get("risk_management", {})

        logger.info(
            f"Strategy initialized: {self.name} v{self.version}",
            extra={
                "strategy": self.name,
                "enabled": self.enabled,
            },
        )

    @abstractmethod
    def scan(
        self,
        symbol: str,
        df: pd.DataFrame,
        company_info: Dict[str, Any],
    ) -> Optional[TradingSignal]:
        """
        Scan a single stock for trading signals.

        Args:
            symbol: Stock symbol.
            df: OHLCV DataFrame (sorted by date, ascending).
            company_info: Company metadata (sector, market_cap, etc).

        Returns:
            TradingSignal if conditions met, None otherwise.
        """
        pass

    def apply_pre_filters(
        self,
        company_info: Dict[str, Any],
    ) -> bool:
        """
        Apply pre-filters before technical analysis.

        Args:
            company_info: Company metadata.

        Returns:
            True if stock passes all filters.
        """
        filters = self.filters_config

        # Market cap filter (skip when value is 0 = data unavailable)
        market_cap = company_info.get("market_cap", 0) or 0
        if market_cap > 0:
            if filters.get("market_cap_min"):
                if market_cap < filters["market_cap_min"]:
                    return False
            if filters.get("market_cap_max"):
                if market_cap > filters["market_cap_max"]:
                    return False

        # Price filter (skip when value is 0 = data unavailable)
        price = company_info.get("last_price", 0) or 0
        if price > 0:
            if filters.get("price_min") and price < filters["price_min"]:
                return False
            if filters.get("price_max") and price > filters["price_max"]:
                return False

        # Financial health: profit growth filter
        # Requires company_info["profit_growth_pct"] to be populated by the
        # caller (e.g. from a screener / fundamental data source).
        # Skipped transparently when the field is absent (data unavailable).
        profit_growth_pct = company_info.get("profit_growth_pct")
        if profit_growth_pct is not None and profit_growth_pct < 0:
            logger.debug(
                f"Financial health rejected: "
                f"profit_growth_pct={profit_growth_pct:.1f}% < 0"
            )
            return False

        return True

    def calculate_stop_loss(
        self,
        entry_price: float,
        df: pd.DataFrame,
    ) -> float:
        """
        Calculate stop loss based on strategy config.

        Args:
            entry_price: Entry price.
            df: OHLCV DataFrame.

        Returns:
            Stop loss price.
        """
        sl_config = self.risk_config.get("stop_loss", {})
        sl_type = sl_config.get("type", "percentage")
        max_pct = sl_config.get("max_percent", 5)

        if sl_type == "atr_based":
            atr = self._calculate_atr(df)
            multiplier = sl_config.get("multiplier", 1.5)
            sl = entry_price - (atr * multiplier)
        elif sl_type == "percentage":
            pct = sl_config.get("percent", 3)
            sl = entry_price * (1 - pct / 100)
        else:
            sl = entry_price * (1 - max_pct / 100)

        # Apply max stop loss cap
        min_sl = entry_price * (1 - max_pct / 100)
        return max(sl, min_sl)

    def calculate_target(
        self,
        entry_price: float,
        stop_loss: float,
        df: pd.DataFrame,
    ) -> float:
        """
        Calculate target price based on strategy config.

        Args:
            entry_price: Entry price.
            stop_loss: Stop loss price.
            df: OHLCV DataFrame.

        Returns:
            Target price.
        """
        target_config = self.risk_config.get("target", {})
        target_type = target_config.get("type", "risk_reward")

        if target_type == "risk_reward":
            ratio = target_config.get("ratio", 2.0)
            risk = entry_price - stop_loss
            return entry_price + (risk * ratio)
        elif target_type == "percentage":
            pct = target_config.get("percent", 10)
            return entry_price * (1 + pct / 100)
        elif target_type == "mean_target":
            # Target is a moving average level
            from src.strategies.indicators.moving_averages import ema
            target_level = target_config.get(
                "target_level", "ema_20"
            )
            period = int(
                target_level.replace("ema_", "").replace("sma_", "")
            )
            ma = ema(df["close"], period)
            return float(ma.iloc[-1])
        else:
            # Default 2:1 risk-reward
            risk = entry_price - stop_loss
            return entry_price + (risk * 2)

    def _calculate_atr(
        self,
        df: pd.DataFrame,
        period: int = 14,
    ) -> float:
        """
        Calculate Average True Range using Wilder's recursive smoothing.

        Wilder's formula: ATR[i] = (ATR[i-1] * (n-1) + TR[i]) / n
        This is the standard method used by TradingView, Zerodha, and most
        charting platforms. EWM (span=period) gives slightly different
        (lower) values and produces tighter SL levels than intended.

        Args:
            df: OHLCV DataFrame.
            period: ATR lookback period.

        Returns:
            Current ATR value.
        """
        from src.strategies.indicators.oscillators import wilder_atr

        atr_series = wilder_atr(df["high"], df["low"], df["close"], period)
        val = atr_series.iloc[-1]
        if pd.isna(val):
            # Fallback: EWM when insufficient data for Wilder's
            tr1 = df["high"] - df["low"]
            tr2 = (df["high"] - df["close"].shift(1)).abs()
            tr3 = (df["low"] - df["close"].shift(1)).abs()
            tr = pd.concat([tr1, tr2, tr3], axis=1).max(axis=1)
            val = float(tr.ewm(span=period, adjust=False).mean().iloc[-1])
        return float(val)

    def _get_atr_multiplier(
        self,
        df: pd.DataFrame,
        period: int = 14,
        multiplier: float = 1.5,
    ) -> float:
        """
        Return ATR × multiplier as an adaptive stop-loss distance.

        Use this instead of a fixed-percentage SL so that the stop
        automatically tightens on low-volatility stocks and widens on
        high-volatility ones, matching the stock's natural noise.

        Usage:
            atr_sl = entry_price - self._get_atr_multiplier(df)

        Args:
            df: OHLCV DataFrame.
            period: ATR lookback period (default 14).
            multiplier: Factor applied to ATR (default 1.5).

        Returns:
            ATR × multiplier as an absolute price distance.
        """
        return self._calculate_atr(df, period) * multiplier

    def _check_strong_close(self, df: pd.DataFrame) -> bool:
        """
        Breakout quality / wick-rejection filter.

        A BUY signal is only valid if the breakout candle closes in the
        top 25 % of its High-Low range, i.e. the close-to-low distance
        is at least 75 % of the total candle range:

            (close - low) / (high - low) >= 0.75

        This filters out bearish-wick candles where the price surged
        intraday but was rejected back down — a classic false breakout.

        Doji candles (range == 0) are treated as neutral and return True
        so they are not incorrectly rejected.

        Args:
            df: OHLCV DataFrame; the *last* row is the breakout candle.

        Returns:
            True if the close qualifies as a strong close, False otherwise.
        """
        last = df.iloc[-1]
        high = float(last["high"])
        low = float(last["low"])
        close = float(last["close"])
        candle_range = high - low
        if candle_range <= 0:
            return True  # Doji / flat candle — neutral, do not reject
        return (close - low) / candle_range >= 0.75

    def validate_signal_rules(
        self,
        entry_price: float,
        target_price: float,
        stop_loss: float,
        df: pd.DataFrame,
        min_rr: float = 1.5,
        dma_wall_pct: float = 2.0,
    ) -> tuple:
        """
        Apply three universal signal validation rules for BUY signals.

        Rule 1 – Price logic   : target > entry > stop_loss.
        Rule 2 – R:R minimum   : (target - entry) / (entry - stop_loss)
                                 must be >= min_rr (default 1.5).
        Rule 3 – 200-DMA wall  : do NOT signal buy when the 200-day SMA
                                 sits within dma_wall_pct% above the entry
                                 price (overhead resistance too close).

        Args:
            entry_price:  Planned entry price.
            target_price: Target / take-profit price.
            stop_loss:    Stop-loss price.
            df:           Full OHLCV DataFrame (for 200-SMA calculation).
            min_rr:       Minimum required R:R ratio (default 1.5).
            dma_wall_pct: DMA proximity threshold in % (default 2.0).

        Returns:
            (True, "")              when all rules pass.
            (False, reason_string)  on the first rule failure.
        """
        # Rule 1 – BUY price logic
        if target_price <= entry_price:
            return False, "rule1_target_not_above_entry"
        if stop_loss >= entry_price:
            return False, "rule1_sl_not_below_entry"

        # Rule 2 – Minimum R:R
        risk = entry_price - stop_loss
        rr = (target_price - entry_price) / risk if risk > 0 else 0.0
        if rr < min_rr:
            return False, f"rule2_rr_{rr:.2f}_below_min_{min_rr}"

        # Rule 3 – 200-DMA overhead resistance wall
        if len(df) >= 200:
            dma200 = float(df["close"].rolling(200).mean().iloc[-1])
            wall_ceiling = entry_price * (1 + dma_wall_pct / 100)
            if entry_price < dma200 <= wall_ceiling:
                return False, f"rule3_dma200_{dma200:.2f}_within_{dma_wall_pct}pct_above_entry"

        return True, ""

    def calculate_position_size(
        self,
        entry_price: float,
        stop_loss: float,
        capital: float = 1_000_000.0,
        risk_pct: float = 1.0,
    ) -> tuple:
        """
        Risk-at-Risk position sizing.

        Calculates the exact share quantity so that if the stop-loss is
        hit, the portfolio loses exactly ``risk_pct`` % of ``capital``.

            risk_amount = capital × risk_pct / 100
            shares      = floor(risk_amount / (entry_price − stop_loss))

        Args:
            entry_price: Planned entry price (INR).
            stop_loss:   Stop-loss price (INR).
            capital:     Total portfolio value in INR (default ₹10,00,000).
            risk_pct:    Max loss per trade as % of capital (default 1%).

        Returns:
            (shares: int, risk_amount: float)
            shares is 0 when risk_per_share <= 0.
        """
        import math
        risk_per_share = entry_price - stop_loss
        if risk_per_share <= 0:
            return 0, 0.0
        risk_amount = capital * risk_pct / 100
        shares = math.floor(risk_amount / risk_per_share)
        return max(shares, 0), round(risk_amount, 2)
