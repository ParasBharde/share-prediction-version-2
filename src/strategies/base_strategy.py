"""
Abstract Base Strategy

Purpose:
    Defines the interface all trading strategies must implement.
    Provides common analysis and signal generation utilities.

Dependencies:
    - pandas for data handling

Logging:
    Strategy execution at INFO, signal generation at INFO.

Fallbacks:
    If individual indicator fails, it's skipped (not fatal).
"""

from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from datetime import datetime
from typing import Any, Dict, List, Optional

import pandas as pd

from src.monitoring.logger import get_logger
from src.utils.constants import AlertPriority, SignalType

logger = get_logger(__name__)


@dataclass
class TradingSignal:
    """Represents a trading signal generated by a strategy."""

    symbol: str
    company_name: str
    strategy_name: str
    signal_type: SignalType
    confidence: float  # 0.0 to 1.0
    entry_price: float
    target_price: float
    stop_loss: float
    priority: AlertPriority
    indicators_met: int
    total_indicators: int
    indicator_details: Dict[str, Any] = field(
        default_factory=dict
    )
    metadata: Dict[str, Any] = field(default_factory=dict)
    generated_at: datetime = field(
        default_factory=datetime.now
    )

    @property
    def target_percent(self) -> float:
        """Calculate target percentage from entry (always positive)."""
        if self.entry_price <= 0:
            return 0.0
        return (
            abs(self.target_price - self.entry_price)
            / self.entry_price
            * 100
        )

    @property
    def stop_loss_percent(self) -> float:
        """Calculate stop loss percentage from entry (always positive)."""
        if self.entry_price <= 0:
            return 0.0
        return (
            abs(self.entry_price - self.stop_loss)
            / self.entry_price
            * 100
        )

    @property
    def risk_reward_ratio(self) -> float:
        """Calculate risk-reward ratio (works for both BUY and SELL)."""
        risk = abs(self.entry_price - self.stop_loss)
        if risk <= 0:
            return 0.0
        reward = abs(self.target_price - self.entry_price)
        return reward / risk

    def to_dict(self) -> Dict[str, Any]:
        """Convert signal to dictionary."""
        return {
            "symbol": self.symbol,
            "company_name": self.company_name,
            "strategy_name": self.strategy_name,
            "signal_type": self.signal_type.value,
            "confidence": self.confidence,
            "entry_price": self.entry_price,
            "target_price": self.target_price,
            "stop_loss": self.stop_loss,
            "priority": self.priority.value,
            "indicators_met": self.indicators_met,
            "total_indicators": self.total_indicators,
            "target_percent": self.target_percent,
            "stop_loss_percent": self.stop_loss_percent,
            "risk_reward_ratio": self.risk_reward_ratio,
            "indicator_details": self.indicator_details,
            "metadata": self.metadata,
            "generated_at": self.generated_at.isoformat(),
        }


class BaseStrategy(ABC):
    """Abstract base class for trading strategies."""

    def __init__(self, config: Dict[str, Any]):
        """
        Initialize strategy with configuration.

        Args:
            config: Strategy configuration dictionary.
        """
        self.config = config
        self.strategy_config = config.get("strategy", {})
        self.name = self.strategy_config.get(
            "name", "Unknown Strategy"
        )
        self.version = self.strategy_config.get("version", "1.0")
        self.enabled = self.strategy_config.get("enabled", True)
        self.priority = self.strategy_config.get("priority", 10)

        self.filters_config = config.get("filters", {})
        self.indicators_config = config.get("indicators", [])
        self.signal_config = config.get("signal_generation", {})
        self.risk_config = config.get("risk_management", {})

        logger.info(
            f"Strategy initialized: {self.name} v{self.version}",
            extra={
                "strategy": self.name,
                "enabled": self.enabled,
            },
        )

    @abstractmethod
    def scan(
        self,
        symbol: str,
        df: pd.DataFrame,
        company_info: Dict[str, Any],
    ) -> Optional[TradingSignal]:
        """
        Scan a single stock for trading signals.

        Args:
            symbol: Stock symbol.
            df: OHLCV DataFrame (sorted by date, ascending).
            company_info: Company metadata (sector, market_cap, etc).

        Returns:
            TradingSignal if conditions met, None otherwise.
        """
        pass

    def apply_pre_filters(
        self,
        company_info: Dict[str, Any],
    ) -> bool:
        """
        Apply pre-filters before technical analysis.

        Args:
            company_info: Company metadata.

        Returns:
            True if stock passes all filters.
        """
        filters = self.filters_config

        # Market cap filter (skip when value is 0 = data unavailable)
        market_cap = company_info.get("market_cap", 0) or 0
        if market_cap > 0:
            if filters.get("market_cap_min"):
                if market_cap < filters["market_cap_min"]:
                    return False
            if filters.get("market_cap_max"):
                if market_cap > filters["market_cap_max"]:
                    return False

        # Price filter (skip when value is 0 = data unavailable)
        price = company_info.get("last_price", 0) or 0
        if price > 0:
            if filters.get("price_min") and price < filters["price_min"]:
                return False
            if filters.get("price_max") and price > filters["price_max"]:
                return False

        return True

    def calculate_stop_loss(
        self,
        entry_price: float,
        df: pd.DataFrame,
    ) -> float:
        """
        Calculate stop loss based on strategy config.

        Args:
            entry_price: Entry price.
            df: OHLCV DataFrame.

        Returns:
            Stop loss price.
        """
        sl_config = self.risk_config.get("stop_loss", {})
        sl_type = sl_config.get("type", "percentage")
        max_pct = sl_config.get("max_percent", 5)

        if sl_type == "atr_based":
            atr = self._calculate_atr(df)
            multiplier = sl_config.get("multiplier", 1.5)
            sl = entry_price - (atr * multiplier)
        elif sl_type == "percentage":
            pct = sl_config.get("percent", 3)
            sl = entry_price * (1 - pct / 100)
        else:
            sl = entry_price * (1 - max_pct / 100)

        # Apply max stop loss cap
        min_sl = entry_price * (1 - max_pct / 100)
        return max(sl, min_sl)

    def calculate_target(
        self,
        entry_price: float,
        stop_loss: float,
        df: pd.DataFrame,
    ) -> float:
        """
        Calculate target price based on strategy config.

        Args:
            entry_price: Entry price.
            stop_loss: Stop loss price.
            df: OHLCV DataFrame.

        Returns:
            Target price.
        """
        target_config = self.risk_config.get("target", {})
        target_type = target_config.get("type", "risk_reward")

        if target_type == "risk_reward":
            ratio = target_config.get("ratio", 2.0)
            risk = entry_price - stop_loss
            return entry_price + (risk * ratio)
        elif target_type == "percentage":
            pct = target_config.get("percent", 10)
            return entry_price * (1 + pct / 100)
        elif target_type == "mean_target":
            # Target is a moving average level
            from src.strategies.indicators.moving_averages import ema
            target_level = target_config.get(
                "target_level", "ema_20"
            )
            period = int(
                target_level.replace("ema_", "").replace("sma_", "")
            )
            ma = ema(df["close"], period)
            return float(ma.iloc[-1])
        else:
            # Default 2:1 risk-reward
            risk = entry_price - stop_loss
            return entry_price + (risk * 2)

    def _calculate_atr(
        self,
        df: pd.DataFrame,
        period: int = 14,
    ) -> float:
        """
        Calculate Average True Range using Wilder's recursive smoothing.

        Wilder's formula: ATR[i] = (ATR[i-1] * (n-1) + TR[i]) / n
        This is the standard method used by TradingView, Zerodha, and most
        charting platforms. EWM (span=period) gives slightly different
        (lower) values and produces tighter SL levels than intended.

        Args:
            df: OHLCV DataFrame.
            period: ATR lookback period.

        Returns:
            Current ATR value.
        """
        from src.strategies.indicators.oscillators import wilder_atr

        atr_series = wilder_atr(df["high"], df["low"], df["close"], period)
        val = atr_series.iloc[-1]
        if pd.isna(val):
            # Fallback: EWM when insufficient data for Wilder's
            tr1 = df["high"] - df["low"]
            tr2 = (df["high"] - df["close"].shift(1)).abs()
            tr3 = (df["low"] - df["close"].shift(1)).abs()
            tr = pd.concat([tr1, tr2, tr3], axis=1).max(axis=1)
            val = float(tr.ewm(span=period, adjust=False).mean().iloc[-1])
        return float(val)
